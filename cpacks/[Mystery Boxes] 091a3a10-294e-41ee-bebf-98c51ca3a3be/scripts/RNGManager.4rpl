# --RNGManager-- 8/16/2021 11:05:48 PM
$EvilMultiplierIncreasePerBox:0.005

#This script RUNS while paused

#Do nothing if this isn't set yet in PreGameSettingsManager.4rpl
-?*MB_OptionDifficulty not if
	return
endif

once
	@UpdateEvilMultiplierButton
endonce

#Frame 1 code
GetGameUpdateCount 1 gte if
	once
		TRUE ->G_bInitialized
		@ResDivFactor ->G_iLastResDivFactor
		
		"Initializing Configuration" Debug
		<-G_iLastResDivFactor @InitializeConfiguration
		
		"Calculating weights and seed" Debug
		@InitializeLootData
		@SeedConfig
		
		return
	endonce
endif

#Mverse
GetTimer1 eq0 if
	30 SetTimer1
	<-G_bInitialized if
		@ResDivFactor ->G_iResDivFactor
		
		#If player count is different.
		<-G_iResDivFactor <-G_iLastResDivFactor neq if
			<-G_iResDivFactor ->G_iLastResDivFactor
			<-G_iResDivFactor @InitializeConfiguration
			@InitializeLootData
			@SeedConfig
			return
		endif
	endif
endif

GetEditMode <-G_bInitialized and if
	once
		"Glory to thee who do not indulge" Debug
		@SeedConfig
		
		return
	endonce
endif

#Reinitialize if difficulty somehow changed
<-*MB_OptionDifficulty <-IC_diff neq if
	@ResDivFactor ->G_iResDivFactor
	<-G_iResDivFactor ->G_iLastResDivFactor
	<-G_iResDivFactor @InitializeConfiguration
	@InitializeLootData
	@SeedConfig
	return
endif


#Mverse things
GetMVersePlayerNum 0 gte if
	#Look over shared units. We only construct these after some frames otherwise they appear
	#still in construction for other players.
	0 ->iI
	while <-iI <-G_ltMverseSharedUnitsToConstruct GetListCount lt repeat
		<-G_ltMverseSharedUnitsToConstruct[<-iI] ->tSharedUnit
		<-tSharedUnit{"StaggerFrames"} 1 sub ->tSharedUnit{"StaggerFrames"}
		<-tSharedUnit{"StaggerFrames"} 0 lte if
			<-tSharedUnit{"UID"} 9999 ConstructUnit
			<-G_ltMverseSharedUnitsToConstruct <-iI RemoveListElement
			<-iI 1 sub ->iI
		endif
		
		<-iI 1 add ->iI
	endwhile
	
	#Look over units that should sync their destruction with other players.
	#We do this less often because units in this list may linger for a while until they are gone.
	GetTimer0 eq0 if
		30 SetTimer0
		
		0 ->iI
		while <-iI <-G_ltMverseUnitsToSyncDestruction GetListCount lt repeat
			<-G_ltMverseUnitsToSyncDestruction[<-iI] ->tUnit
			<-tUnit{"iUID"} ->iUID
			<-iUID GetUnitDestroyed if
				"MB_MverseSyncedUnitDestroyed" <-tUnit SendMVerseMsg
				<-G_ltMverseUnitsToSyncDestruction <-iI RemoveListElement
				<-iI 1 sub ->iI
			endif
			
			<-iI 1 add ->iI
		endwhile
	endif
endif

:awake
	once
		CreateList ->G_ltMverseSharedUnitsToConstruct
		CreateList ->G_ltMverseUnitsToSyncDestruction
		"MB_MysteryBoxOpened" "OnMysteryBoxOpened" RegisterForMsg
		"MB_MverseMysteryBoxOpened" "OnMverseMysteryBoxOpened" RegisterForMsg
		"MB_MverseSyncedUnitDestroyed" "OnMverseSyncedUnitDestroyed" RegisterForMsg
		@UpdateMysteryBoxOpenedButton
	endonce
:once
	@awake

# f1 -
:InitializeConfiguration
	->IC_rdf
	<-*MB_OptionDifficulty ->IC_diff
	
	"MB_DebugMverse" GetMversePlayerNum <-IC_rdf 1 TableN SetGlobalTable
	
	#Unit types that are not included in any of the lists below
	#APPEAR ONLY FOR THE HOST.
	
	#Put unit types in this table if they should only appear
	#FOR THE PLAYER THAT OPENED THEM.
	<-*MB_tCustomGUIDs{"Mystery Box"} 1
	<-*MB_tCustomGUIDs{"Airship"} 1
	<-*MB_tCustomGUIDs{"Bertha"} 1
	<-*MB_tCustomGUIDs{"Sweeper"} 1
	<-*MB_tCustomGUIDs{"Wallis"} 1
	<-*MB_tCustomGUIDs{"ERNMaker"} 1
	<-*MB_tCustomGUIDs{"Flare"} 1 
	<-*MB_tCustomGUIDs{"AC Bomb"} 1
	<-*MB_tCustomGUIDs{"Visual Orbital Giver"} 1
	"tower" 1 "pylon" 1 "miner" 1 "greenarrefinery" 1 "terp" 1 "porter" 1
	"cannon" 1 "mortar" 1 "sprayer" 1 "sniper" 1 "missilelauncher" 1 "nullifier" 1
	"runway" 1 "acbomberpad" 1 "bomberpad" 1 "rocketpad" 1 "platform" 1
	"shield" 1 "microrift" 1 "beacon" 1
	"ern" 1 
	"bertha_combo" 1
	Table ->G_tbMversePlayerUnits
	
	#Put unit types in this table if they should only appear
	#FOR EVERYONE BY DEFAULT.
	#Special behaviors may further restrict creation of specific events.
	#e.g. skimmer_fortress only wants to spawn creeper for host, but units for everyone.

	#TYPE
	"resourcered" 1 "resourceblue" 1 "greenarmother" 1
	"ultrac" 1 "pterosaur" 1
	"emitter" 1 "darktower" 1
	"crystal" 1 
	<-*MB_tCustomGUIDs{"Skimmer Pain"} 1
	#STYPE
	"miner_res" 1
	"solar_farm" 1
	"skimmer_fortress" 1
	"orbital_factory" 1
	"contaminant_bomb" 1
	"breeder_hell" 1
	"creeper" 1 #Only fakeout
	Table ->G_tbMverseTypesSpawnForEveryone
	
	
	#Put unit types in this table
	#THAT SHOULD SYNC THEIR DESTRUCTION WITH OTHER PLAYERS.
	"emitter" 1 "sporelauncher" 1 "blobnest" 1 "skimmerfactory" 1 "darktower" 1
	"airsaccauldron" 1 
	Table ->G_tbMverseNullifiableEnemies
	
	#########
	# Evil Titan Config
	CreateList ->G_ltEvilTitan
	"WEIGHT" 50.0,	"TYPE" <-*MB_tCustomGUIDs{"Orb Volcano"}, "SETTINGS" TableN("Type" "orb", "Payload" 300, "Count" 150, "Height" 25, 4) "SPECIAL" TableN("Seed" TRUE, "Effect" "boom1" 2) 4 TableN
	"WEIGHT" 50.0,	"TYPE" <-*MB_tCustomGUIDs{"Orb Volcano"}, "SETTINGS" TableN("Type" "egg", "Payload" 1200, "Count" 50, "Height" 25, 4)	"SPECIAL" TableN("Seed" TRUE, "Effect" "boom1" 2) 4 TableN
	"WEIGHT" 50.0,	"STYPE" "creeper", 	"SPECIAL" TableN("Payload" 50000, "Effect" "boom1", 2)	3 TableN
	<-G_ltEvilTitan AppendStackToList
	
	
	CreateTable ->G_tttltConf
	
	#########
	# TITAN_MYSTERY_BOX
	CreateTable ->G_tttltConf{"TITAN_MYSTERY_BOX"}
	<-G_tttltConf{"TITAN_MYSTERY_BOX"} "Types"				"Good" CreateList 	"Bad" CreateList   "Neutral" CreateList 	3 TableN SetTableElement
	<-G_tttltConf{"TITAN_MYSTERY_BOX"} "TypeWeights"
		"peace"  "Good" 80.0 "Neutral" 20.0 "Bad" 0.0  3 TableN
		"easy"   "Good" 70.0 "Neutral" 20.0 "Bad" 10.0 3 TableN
		"normal" "Good" 50.0 "Neutral" 20.0 "Bad" 30.0 3 TableN
		"hard"   "Good" 30.0 "Neutral" 20.0 "Bad" 50.0 3 TableN
	4 TableN SetTableElement
	<-G_tttltConf{"TITAN_MYSTERY_BOX"} "CombinedLootList"	CreateList										 SetTableElement
	<-G_tttltConf{"TITAN_MYSTERY_BOX"} "AdjustedProb" 		CreateList									   	 SetTableElement
	<-G_tttltConf{"TITAN_MYSTERY_BOX"} "Aliases" 			CreateList										 SetTableElement
	<-G_tttltConf{"TITAN_MYSTERY_BOX"} "NothingChancePrc" 	0.0										 		 SetTableElement
	<-G_tttltConf{"TITAN_MYSTERY_BOX"} "TotalItems" 		0												 SetTableElement
	<-G_tttltConf{"TITAN_MYSTERY_BOX"} "Seed" 				0												 SetTableElement
	
	
	
	#########
	# <Good> outcomes start here
	"WEIGHT" 30.0,	"STYPE" "orbital_factory",	2 TableN
	"WEIGHT" 80.0,	"TYPE" <-*MB_tCustomGUIDs{"Airship"},  2 TableN
	"WEIGHT" 80.0,	"STYPE" "bertha_combo",	  2 TableN
	<-IC_diff "hard" neq if
		"WEIGHT" 50.0,		"TYPE" <-*MB_tCustomGUIDs{"Sweeper"},	 2 TableN
	endif
	"WEIGHT" 80.0,		"TYPE" <-*MB_tCustomGUIDs{"Wallis"}, "SPECIAL" TableN("Seed" TRUE, 1)	 3 TableN
	"WEIGHT" 50.0,		"TYPE" <-*MB_tCustomGUIDs{"ERNMaker"}, 2 TableN
		<-G_tttltConf{"TITAN_MYSTERY_BOX"}{"Types"}{"Good"} AppendStackToList
	
	#########
	# <Neutral> outcomes start here
	"WEIGHT" 50.0,	"STYPE" "creeper", 	"SPECIAL" TableN("Payload" 50000 <-IC_diff "peace" eq if -1 else 1 endif mul, "Effect" "boom1", 2)	3 TableN
	"WEIGHT" 20.0,	"TYPE" <-*MB_tCustomGUIDs{"Mystery Box"},		"SPECIAL" TableN("Count" 50, "Unselectable" TRUE 2), 	3 TableN
	<-IC_diff "easy" neq if
		"WEIGHT" 25.0,	"STYPE" "creeper", 	"SPECIAL" TableN("Payload" 100000 <-IC_diff "peace" eq if -1 else 1 endif mul, "Effect" "boom2", 2)	3 TableN
	endif
		<-G_tttltConf{"TITAN_MYSTERY_BOX"}{"Types"}{"Neutral"} AppendStackToList
		
	#########
	# <Bad> outcomes start here
	
	#Easy, Normal and Hard difficulty
	"WEIGHT" 50.0,	"TYPE" <-*MB_tCustomGUIDs{"Orb Volcano"}, "SETTINGS" TableN("Type" "orb", "Payload" 300, "Count" 150, "Height" 25, 4) "SPECIAL" TableN("Seed" TRUE, "Effect" "boom1" 2) 4 TableN
	"WEIGHT" 50.0,	"TYPE" <-*MB_tCustomGUIDs{"Orb Volcano"}, "SETTINGS" TableN("Type" "egg", "Payload" 1200, "Count" 50, "Height" 25, 4)	"SPECIAL" TableN("Seed" TRUE, "Effect" "boom1" 2) 4 TableN
	
	<-IC_diff "easy" neq if
		#Normal and Hard difficulty
		"WEIGHT" 25.0,	"TYPE" <-*MB_tCustomGUIDs{"Egg Carrier"}, "SETTINGS" TableN("Type" "spore", "CarrierData" TableN("Target" 2, "Payload" 200, 2), "EggData" TableN("payload" 800, "showpathline" TRUE, "showpathlinecolor" 0.3 0.3 0.7 1 V4 , 3), "Count" 30, "Height" 25, 5), "SPECIAL" TableN("Seed" TRUE, "Effect" "boom2" 2) 4 TableN 
		"WEIGHT" 20.0	"STYPE" "creeper", "SPECIAL" TableN("Payload" 50000, "Effect" "boom1", "Fakeout" TRUE 3)	3 TableN
		"WEIGHT" 5.0,	"STYPE" "creeper", 	"SPECIAL" TableN("Payload" 100000, "Effect" "boom2", "Fakeout" TRUE 3)	3 TableN
		
		<-IC_diff "normal" neq if
			#Hard difficulty
			"WEIGHT" 25.0,	"TYPE" <-*MB_tCustomGUIDs{"Skimmer Pain"}, "SETTINGS" TableN("Interval" 5, 1), "SPECIAL" TableN("Seed" TRUE, "Effect" "boom2" 2) 4 TableN 
			"WEIGHT" 25.0	"TYPE" <-*MB_tCustomGUIDs{"Splitmitter"} "SPECIAL" TableN("Seed" TRUE, "Effect" "boom2", 2) "SETTINGS" TableN("Payload" 1000, "Interval" 300, "SplitHealth" 5, 3) 4 TableN
			"WEIGHT" 25.0,	"STYPE" "skimmer_fortress",	"SPECIAL" TableN("Effect" "boom2", "CrimsonTowers" TRUE, 2) 3 TableN
			"WEIGHT" 25.0,	"STYPE" "breeder_hell",	"SPECIAL" TableN("Effect" "boom2", "Range", 40, 2) 3 TableN
			"WEIGHT" 20.0,	"STYPE" "creeper_cover",	"SPECIAL" TableN("Effect" "boom2", 1) 3 TableN
		else
			#Normal difficulty
			"WEIGHT" 25.0,	"TYPE" <-*MB_tCustomGUIDs{"Skimmer Pain"}, "SETTINGS" TableN("Interval" 25, 1), "SPECIAL" TableN("Effect" "boom2" 1) 4 TableN
			"WEIGHT" 25.0	"TYPE" <-*MB_tCustomGUIDs{"Splitmitter"} "SPECIAL" TableN("Seed" TRUE, "Effect" "boom2", 2) "SETTINGS" TableN("Payload" 1000, "Interval" 300, "SplitHealth" 3, 3) 4 TableN
			"WEIGHT" 25.0,	"STYPE" "skimmer_fortress",	"SPECIAL" TableN("Effect" "boom2", "CrimsonTowers" FALSE, 2) 3 TableN
			"WEIGHT" 25.0,	"STYPE" "breeder_hell",	"SPECIAL" TableN("Effect" "boom2", "Range", 10, 2) 3 TableN
		endif
	endif
		<-G_tttltConf{"TITAN_MYSTERY_BOX"}{"Types"}{"Bad"} AppendStackToList
		

	#########
	# FRIENDLY_MYSTERY_BOX
	CreateTable ->G_tttltConf{"FRIENDLY_MYSTERY_BOX"}
	<-G_tttltConf{"FRIENDLY_MYSTERY_BOX"} "Types"				"Good" CreateList 	1 TableN 	SetTableElement
	<-G_tttltConf{"FRIENDLY_MYSTERY_BOX"} "TypeWeights"
		"peace"  "Good" 100.0 1 TableN
		"easy"   "Good" 100.0 1 TableN
		"normal" "Good" 100.0 1 TableN
		"hard"   "Good" 100.0 1 TableN
	4 TableN SetTableElement
	<-G_tttltConf{"FRIENDLY_MYSTERY_BOX"} "CombinedLootList" 	CreateList						SetTableElement
	<-G_tttltConf{"FRIENDLY_MYSTERY_BOX"} "AdjustedProb" 		CreateList					   	SetTableElement
	<-G_tttltConf{"FRIENDLY_MYSTERY_BOX"} "Aliases" 			CreateList						SetTableElement
	<-G_tttltConf{"FRIENDLY_MYSTERY_BOX"} "NothingChancePrc" 	0.0								SetTableElement
	<-G_tttltConf{"FRIENDLY_MYSTERY_BOX"} "TotalItems" 			0								SetTableElement
	<-G_tttltConf{"FRIENDLY_MYSTERY_BOX"} "Seed" 				0								SetTableElement
	
	#########
	# <Good> outcomes start here
	"WEIGHT" 90.0,	"TYPE" "cannon",			2 TableN
	"WEIGHT" 90.0,	"TYPE" "mortar",			2 TableN
	"WEIGHT" 45.0,	"TYPE" "sprayer",			2 TableN
	"WEIGHT" 30.0,	"TYPE" "sniper",			2 TableN
	"WEIGHT" 30.0,	"TYPE" "missilelauncher",	2 TableN
	"WEIGHT" 25.0 <-IC_rdf div,	"STYPE" "miner_res",		"SPECIAL" TableN("Coverage" 50.0, 1) 3 TableN
	#"WEIGHT" 25.0 <-IC_rdf div,	"TYPE" "resourcered",	"SETTINGS" TableN("Interval" 75, 1), 	3 TableN
	#"WEIGHT" 25.0 <-IC_rdf div,	"TYPE" "resourceblue",	"SETTINGS" TableN("Interval" 75, 1), 	3 TableN
	"WEIGHT" 25.0,	"STYPE" "creeper", 		"SPECIAL" TableN("Payload" -750, 1),	3 TableN
	"WEIGHT" 15.0,	"STYPE" "creeper", 		"SPECIAL" TableN("Payload" -1000, 1),	3 TableN
	"WEIGHT" 4.4,	"TYPE" "ern",				2 TableN
		<-G_tttltConf{"FRIENDLY_MYSTERY_BOX"}{"Types"}{"Good"} AppendStackToList
	
	
	
	#########
	# REGULAR_MYSTERY_BOX
	CreateTable ->G_tttltConf{"REGULAR_MYSTERY_BOX"}
	<-G_tttltConf{"REGULAR_MYSTERY_BOX"} "Types"			"Good" CreateList "Bad" CreateList "Currency" CreateList 3 TableN SetTableElement
	<-G_tttltConf{"REGULAR_MYSTERY_BOX"} "TypeWeights"
		"peace"  "Good" 45.0 "Bad" 0.0  "Currency" 5.0 3 TableN
		"easy"   "Good" 45.0 "Bad" 15.0 "Currency" 5.0 3 TableN
		"normal" "Good" 45.0 "Bad" 30.0 "Currency" 5.0 3 TableN
		"hard"   "Good" 45.0 "Bad" 55.0 "Currency" 5.0 3 TableN
	4 TableN SetTableElement
	<-G_tttltConf{"REGULAR_MYSTERY_BOX"} "CombinedLootList" 	CreateList									 SetTableElement
	<-G_tttltConf{"REGULAR_MYSTERY_BOX"} "AdjustedProb" 		CreateList									 SetTableElement
	<-G_tttltConf{"REGULAR_MYSTERY_BOX"} "Aliases" 				CreateList									 SetTableElement
	<-G_tttltConf{"REGULAR_MYSTERY_BOX"} "NothingChancePrc" 	0.0										 	 SetTableElement
	<-G_tttltConf{"REGULAR_MYSTERY_BOX"} "TotalItems" 			0											 SetTableElement
	<-G_tttltConf{"REGULAR_MYSTERY_BOX"} "Seed" 				0											 SetTableElement
	
	#########
	# <Currency> outcomes start here
	"WEIGHT" 50.0,	"STYPE" "miner_res", 		"SPECIAL" TableN("Coverage" 75.0, "SpawnTwo" TRUE, 2) 3 TableN
	"WEIGHT" 50.0,	"TYPE" "ern",				"SPECIAL" TableN("CountMin" 1, "CountMax" 2, 2) 3 TableN
		<-G_tttltConf{"REGULAR_MYSTERY_BOX"}{"Types"}{"Currency"} AppendStackToList
	
	#########
	# <Good> outcomes start here
	
	#All difficulties
	"WEIGHT" 160.0,	"TYPE" "mortar",			"SPECIAL" TableN("CountMin" 1, "CountMax" 4, 2) 3 TableN
	"WEIGHT" 140.0,	"TYPE" "cannon",			"SPECIAL" TableN("CountMin" 1, "CountMax" 4, 2) 3 TableN
	"WEIGHT" 100.0,	"TYPE" "sniper",			"SPECIAL" TableN("CountMin" 1, "CountMax" 2, 2) 3 TableN
	"WEIGHT" 100.0,	"TYPE" "missilelauncher",	"SPECIAL" TableN("CountMin" 1, "CountMax" 2, 2) 3 TableN
	"WEIGHT" 80.0,	"TYPE" "shield",			"SPECIAL" TableN("CountMin" 1, "CountMax" 4, 2) 3 TableN
	"WEIGHT" 80.0,	"TYPE" "sprayer",			"SPECIAL" TableN("CountMin" 1, "CountMax" 4, 2) 3 TableN
	"WEIGHT" 60.0,	"TYPE" "terp",				"SPECIAL" TableN("CountMin" 1, "CountMax" 4, 2) 3 TableN
	"WEIGHT" 45.0,	"TYPE" "beacon",			2 TableN
	"WEIGHT" 30.0,	"TYPE" <-*MB_tCustomGUIDs{"AC Bomb"},   "SPECIAL" TableN("Count" 1, 1) 3 TableN
	"WEIGHT" 7.5,	"TYPE" <-*MB_tCustomGUIDs{"AC Bomb"},   "SPECIAL" TableN("Count" 2, 1) 3 TableN
	"WEIGHT" 40.0,	"TYPE" <-*MB_tCustomGUIDs{"Flare"},  "SPECIAL" TableN("Seed" TRUE, "Count" 1, 2) 3 TableN
	"WEIGHT" 10.0,	"TYPE" <-*MB_tCustomGUIDs{"Flare"},  "SPECIAL" TableN("Seed" TRUE, "Count" 2, 2) 3 TableN
	
	#-----------
	
	"WEIGHT" 125.0,	"TYPE" "greenarrefinery", 	"SPECIAL" TableN("CountMin" 1, "CountMax" 2, 2) 3 TableN
	"WEIGHT" 75.0 <-IC_rdf div,	"STYPE" "solar_farm",	2 TableN
	
	#-----------
	
	"WEIGHT" 40.0,	"TYPE" "microrift",			2 TableN
	"WEIGHT" 40.0,	"TYPE" "ultrac",			2 TableN
	
	#-----------
	
	"WEIGHT" 20.0,	"TYPE" "pterosaur",			"SPECIAL" TableN("CountMin" 1, "CountMax" 3, 2) 3 TableN
	
	#-----------
	
	"WEIGHT" 10.0,	"STYPE" "u_wall",		"SPECIAL" TableN("Type" "wall", 1) 3 TableN
	
	#-----------
	
	"WEIGHT" 100.0,	"TYPE" <-*MB_tCustomGUIDs{"Mystery Box"},		"SPECIAL" TableN("Count" 4, "Unselectable" TRUE 2), 	3 TableN
	"WEIGHT" 20.0,	"TYPE" <-*MB_tCustomGUIDs{"Mystery Box"},		"SPECIAL" TableN("Count" 8, "Unselectable" TRUE, "Effect" "boom1",  3), 	3 TableN
	"WEIGHT" 5.0,	"TYPE" <-*MB_tCustomGUIDs{"Mystery Box"},		"SPECIAL" TableN("Count" 12, "Unselectable" TRUE, "Effect" "boom2", 3), 	3 TableN
	"WEIGHT" 5.0,	"TYPE" "emitter",		"SETTINGS" TableN("Start" 0, 	"Interval" 15, 	"Payload" -20, 3), 	3 TableN
	"WEIGHT" 200.0,	"STYPE" "creeper", 		"SPECIAL" TableN("Payload" -1000, 1),	3 TableN
	"WEIGHT" 150.0,	"STYPE" "creeper", 		"SPECIAL" TableN("Payload" -1500, 1),	3 TableN
	"WEIGHT" 100.0,	"STYPE" "creeper", 		"SPECIAL" TableN("Payload" -2000, 1),	3 TableN
	
	<-IC_diff "hard" neq if
		#Peaceful, Easy and Normal difficulty
	
		"WEIGHT" 50.0,	"TYPE" "rocketpad",			2 TableN
	else
		#Hard difficulty
		
		"WEIGHT" 50.0,	"TYPE" <-*MB_tCustomGUIDs{"Visual Orbital Giver"},	"SETTINGS" TableN("Orbitals" 2, 1),		3 TableN
	endif
	
		<-G_tttltConf{"REGULAR_MYSTERY_BOX"}{"Types"}{"Good"} AppendStackToList
	
	
	#########
	# <Bad> outcomes start here
	
	#All difficulties
	"WEIGHT" 15.0,	"TYPE" "crystal",	2 TableN
	"WEIGHT" 7.5,	"STYPE" "smiley_face", 	2 TableN
	
	<-IC_diff "easy" neq if
		#Normal and Hard difficulty
		"WEIGHT" 7.5,	"STYPE" "contaminant_bomb", 	"SPECIAL" TableN("Range" 10, 1)	3 TableN
		"WEIGHT" 7.5,	"TYPE" "darktower",	"SETTINGS" TableN("Width" 14, 	"Depth" 14,  2),	"SPECIAL" TableN("Effect" "boom1", 1), 	4 TableN
		"WEIGHT" 5.0,	"TYPE" "crystal", 	"SPECIAL" TableN("CountMin" 2, "CountMax" 4, 2)	3 TableN
		
		<-IC_diff "normal" neq if
			#Hard difficulty
			"WEIGHT" 75.0,	"TYPE" "blob",		"SETTINGS" 	TableN("Target" 0,  "Payload" 150,  2), 					"SPECIAL" TableN("CountMin" 4,  "CountMax" 6,  "Height" 0,   "ScaleHard" 1.0,    4),	4 TableN
			"WEIGHT" 25.0,	"TYPE" "blob",		"SETTINGS" 	TableN("Target" 0,  "Payload" 200,  2), 					"SPECIAL" TableN("CountMin" 6,  "CountMax" 8,  "Height" 0,   "ScaleHard" 1.0,    4),	4 TableN
			"WEIGHT" 5.0,	"TYPE" "blob",		"SETTINGS" 	TableN("Target" 0,  "Payload" 200,  2),						"SPECIAL" TableN("CountMin" 13, "CountMax" 20, "Height" 0,   "ScaleHard" 1.0, "Effect" "boom1",   5)	4 TableN
			"WEIGHT" 75.0,	"TYPE" "skimmer",	"SETTINGS"  TableN("Target" 0,  "Payload" 0, 	"LifeTime" 30,  3),		"SPECIAL" TableN("CountMin" 2,  "CountMax" 4,  "Height" 7,   "ScaleHard" 1.0,    4), 	4 TableN
			"WEIGHT" 25.0,	"TYPE" "skimmer",	"SETTINGS"  TableN("Target" 0,  "Payload" 0, 	"LifeTime" 30,  3), 	"SPECIAL" TableN("CountMin" 5,  "CountMax" 8,  "Height" 14,  "ScaleHard" 1.0,    4), 	4 TableN
			"WEIGHT" 5.0,	"TYPE" "skimmer",	"SETTINGS"  TableN("Target" 0,  "Payload" 0, 	"LifeTime" 210, 3), 	"SPECIAL" TableN("CountMin" 12, "CountMax" 36, "Height" 400, "ScaleHard" 1.0, "Effect" "boom1"    5), 	4 TableN
			"WEIGHT" 75.0,	"TYPE" "airsac",	"SETTINGS"  TableN("Target" 0,  "Payload" 20,   2),						"SPECIAL" TableN("Count" 1, 	               "Height" 37,  "ScaleHard" 2.0,    3), 	4 TableN
			"WEIGHT" 25.0,	"TYPE" "airsac",	"SETTINGS"  TableN("Target" 0,  "Payload" 75,   2),						"SPECIAL" TableN("Count" 2, 	               "Height" 37,  "ScaleHard" 2.0,    3), 	4 TableN
			"WEIGHT" 5.0,	"TYPE" "airsac",	"SETTINGS"  TableN("Target" 0,  "Payload" 150,  2),						"SPECIAL" TableN("Count" 3, 	               "Height" 37,  "ScaleHard" 2.0, "Effect" "boom1",   4), 	4 TableN
			"WEIGHT" 50.0,	"TYPE" "emitter",	"SETTINGS" 	TableN("Start" 300, "Payload" 50,	"Interval" 60, 	 3),  	"SPECIAL" TableN(											 "ScaleHard" 2.0, 1),	4 TableN
			"WEIGHT" 17.5,	"TYPE" "emitter",	"SETTINGS" 	TableN("Start" 300, "Payload" 100,	"Interval" 60, 	 3), 	"SPECIAL" TableN(											 "ScaleHard" 2.0, 1),	4 TableN
			"WEIGHT" 2.5,	"TYPE" "emitter",	"SETTINGS" 	TableN("Start" 300, "Payload" 200,	"Interval" 60, 	 3), 	"SPECIAL" TableN(											 "ScaleHard" 2.0, "Effect" "boom1",   2) 	4 TableN
			"WEIGHT" 75.0,	"TYPE" "spore",		"SETTINGS" 	TableN("Target" 0,  "Payload" 200,  2), 					"SPECIAL" TableN("CountMin" 4,  "CountMax" 8,  "Height" 0,   "ScaleHard" 1.0, 4)	4 TableN
			"WEIGHT" 25.0,	"TYPE" "spore",		"SETTINGS" 	TableN("Target" 0,  "Payload" 500,  2), 					"SPECIAL" TableN("CountMin" 8,  "CountMax" 12, "Height" 0,   "ScaleHard" 1.0, 4)	4 TableN
			"WEIGHT" 5.0,	"TYPE" "spore",		"SETTINGS" 	TableN("Target" 0,  "Payload" 1500, 2), 					"SPECIAL" TableN("CountMin" 12, "CountMax" 20, "Height" 0,   "ScaleHard" 1.0, "Effect" "boom1",   5)	4 TableN
			"WEIGHT" 75.0,	"STYPE" "creeper", 																			"SPECIAL" TableN("Payload" 1500, 							 "ScaleHard" 1.5, 2)	3 TableN
			"WEIGHT" 25.0,	"STYPE" "creeper", 																			"SPECIAL" TableN("Payload" 2000, 							 "ScaleHard" 1.5, 2)	3 TableN
			"WEIGHT" 5.0,	"STYPE" "creeper", 																			"SPECIAL" TableN("Payload" 3000,  							 "ScaleHard" 1.5, "Effect" "boom1",   3)	3 TableN
			GetMVersePlayerNum lt0 if "WEIGHT" 75.0,	"TYPE" "forb",													"SPECIAL" TableN("CountMin" 2, "CountMax" 4, "Height" 0, 	 "ScaleHard" 1.0, 4)	3 TableN endif
			GetMVersePlayerNum lt0 if "WEIGHT" 25.0,	"TYPE" "forb",													"SPECIAL" TableN("CountMin" 5, "CountMax" 7, "Height" 0, 	 "ScaleHard" 1.0, 4)	3 TableN endif
			GetMVersePlayerNum lt0 if "WEIGHT" 5.0,		"TYPE" "forb",													"SPECIAL" TableN("CountMin" 10, "CountMax" 14, "Height" 0, 	 "ScaleHard" 1.0, "Effect" "boom1",   5)	3 TableN endif
		else
			#Normal difficulty
			"WEIGHT" 75.0,	"TYPE" "blob",		"SETTINGS" 	TableN("Target" 0, "Payload" 100, 2), 	"SPECIAL" TableN("CountMin" 4, "CountMax" 6, "Height" 0, 3)	4 TableN
			"WEIGHT" 25.0,	"TYPE" "blob",		"SETTINGS" 	TableN("Target" 0, "Payload" 150, 2), 	"SPECIAL" TableN("CountMin" 6, "CountMax" 8, "Height" 0, 3)	4 TableN
			"WEIGHT" 5.0,	"TYPE" "blob",		"SETTINGS" 	TableN("Target" 0, "Payload" 200, 2),	"SPECIAL" TableN("CountMin" 8, "CountMax" 10, "Height" 0, "Effect" "boom1", 4)	4 TableN
			"WEIGHT" 75.0,	"TYPE" "skimmer",	"SETTINGS" TableN("Target" 0, 	"Payload" 0, 	"LifeTime" 30, 3),	"SPECIAL" TableN("CountMin" 2, "CountMax" 3, 	"Height" 7, 3), 	4 TableN
			"WEIGHT" 25.0,	"TYPE" "skimmer",	"SETTINGS" TableN("Target" 0, 	"Payload" 0, 	"LifeTime" 30, 3), 	"SPECIAL" TableN("CountMin" 4, "CountMax" 6, 	"Height" 14, 3), 	4 TableN
			"WEIGHT" 5.0,	"TYPE" "skimmer",	"SETTINGS" TableN("Target" 0, 	"Payload" 0, 	"LifeTime" 210, 3), "SPECIAL" TableN("CountMin" 8, "CountMax" 24, 	"Height" 400, "Effect" "boom1" 4), 	4 TableN
			"WEIGHT" 75.0,	"TYPE" "airsac",	"SETTINGS" TableN("Target" 0, 	"Payload" 10, 2),	"SPECIAL" TableN("Count" 1, 	"Height" 37, 2), 	4 TableN
			"WEIGHT" 25.0,	"TYPE" "airsac",	"SETTINGS" TableN("Target" 0, 	"Payload" 30, 2),	"SPECIAL" TableN("Count" 2, 	"Height" 37, 2), 	4 TableN
			"WEIGHT" 5.0,	"TYPE" "airsac",	"SETTINGS" TableN("Target" 0, 	"Payload" 75, 2),	"SPECIAL" TableN("Count" 3, 	"Height" 37, "Effect" "boom1", 3), 	4 TableN
			"WEIGHT" 50.0,	"TYPE" "emitter",	"SETTINGS" 	TableN("Start" 300, 	"Interval" 60, 	"Payload" 25, 3), 	3 TableN
			"WEIGHT" 17.5,	"TYPE" "emitter",	"SETTINGS" 	TableN("Start" 300, 	"Interval" 60, 	"Payload" 75, 3), 	3 TableN
			"WEIGHT" 2.5,	"TYPE" "emitter",	"SETTINGS" 	TableN("Start" 300, 	"Interval" 60, 	"Payload" 150, 3), "SPECIAL" TableN("Effect" "boom1", 1) 	4 TableN
			"WEIGHT" 75.0,	"TYPE" "spore",		"SETTINGS" 	TableN("Target" 0, "Payload" 100, 2), 	"SPECIAL" TableN("CountMin" 3, "CountMax" 6, "Height" 0, 3)	4 TableN
			"WEIGHT" 25.0,	"TYPE" "spore",		"SETTINGS" 	TableN("Target" 0, "Payload" 250, 2), 	"SPECIAL" TableN("CountMin" 6, "CountMax" 9, "Height" 0, 3)	4 TableN
			"WEIGHT" 5.0,	"TYPE" "spore",		"SETTINGS" 	TableN("Target" 0, "Payload" 750, 2), 	"SPECIAL" TableN("CountMin" 9, "CountMax" 15, "Height" 0, "Effect" "boom1", 4)	4 TableN
			"WEIGHT" 75.0,	"STYPE" "creeper", 	"SPECIAL" TableN("Payload" 1000, 1)	3 TableN
			"WEIGHT" 25.0,	"STYPE" "creeper", 	"SPECIAL" TableN("Payload" 1500, 1)	3 TableN
			"WEIGHT" 5.0,	"STYPE" "creeper", 	"SPECIAL" TableN("Payload" 2000, "Effect" "boom1", 2)	3 TableN
			GetMVersePlayerNum lt0 if "WEIGHT" 75.0,	"TYPE" "forb",		"SPECIAL" TableN("CountMin" 2, "CountMax" 3, "Height" 0, 3)	3 TableN endif
			GetMVersePlayerNum lt0 if "WEIGHT" 25.0,	"TYPE" "forb",		"SPECIAL" TableN("CountMin" 3, "CountMax" 4, "Height" 0, 3)	3 TableN endif
			GetMVersePlayerNum lt0 if "WEIGHT" 5.0,	"TYPE" "forb",		"SPECIAL" TableN("CountMin" 6, "CountMax" 10, "Height" 0, "Effect" "boom1", 4)	3 TableN endif
		endif
	else
		#Easy difficulty
		"WEIGHT" 75.0,	"TYPE" "blob",		"SETTINGS" 	TableN("Target" 0, "Payload" 100, 2), 	"SPECIAL" TableN("CountMin" 2, "CountMax" 3, "Height" 0, 3)	4 TableN
		"WEIGHT" 25.0,	"TYPE" "blob",		"SETTINGS" 	TableN("Target" 0, "Payload" 100, 2), 	"SPECIAL" TableN("CountMin" 4, "CountMax" 5, "Height" 0, 3)	4 TableN
		"WEIGHT" 75.0,	"TYPE" "skimmer",	"SETTINGS" TableN("Target" 0, 	"Payload" 0, 	"LifeTime" 30, 3),	"SPECIAL" TableN("CountMin" 1, "CountMax" 2, 	"Height" 7, 3), 	4 TableN
		"WEIGHT" 25.0,	"TYPE" "skimmer",	"SETTINGS" TableN("Target" 0, 	"Payload" 0, 	"LifeTime" 30, 3), 	"SPECIAL" TableN("CountMin" 3, "CountMax" 4, 	"Height" 14, 3), 	4 TableN
		"WEIGHT" 75.0,	"TYPE" "airsac",	"SETTINGS" TableN("Target" 0, 	"Payload" 5, 2),	"SPECIAL" TableN("Count" 1, 	"Height" 0, 2), 	4 TableN
		"WEIGHT" 25.0,	"TYPE" "airsac",	"SETTINGS" TableN("Target" 0, 	"Payload" 10, 2),	"SPECIAL" TableN("Count" 2, 	"Height" 0, 2), 	4 TableN
		"WEIGHT" 50.0,	"TYPE" "emitter",	"SETTINGS" 	TableN("Start" 300, 	"Interval" 60, 	"Payload" 10, 3), 	3 TableN
		"WEIGHT" 17.5,	"TYPE" "emitter",	"SETTINGS" 	TableN("Start" 300, 	"Interval" 60, 	"Payload" 25, 3), 	3 TableN
		"WEIGHT" 75.0,	"TYPE" "spore",		"SETTINGS" 	TableN("Target" 0, "Payload" 25, 2), 	"SPECIAL" TableN("CountMin" 2, "CountMax" 4, "Height" 0, 3)	4 TableN
		"WEIGHT" 25.0,	"TYPE" "spore",		"SETTINGS" 	TableN("Target" 0, "Payload" 75, 2), 	"SPECIAL" TableN("CountMin" 4, "CountMax" 6, "Height" 0, 3)	4 TableN
		"WEIGHT" 75.0,	"STYPE" "creeper", 	"SPECIAL" TableN("Payload" 500, 1)	3 TableN
		"WEIGHT" 25.0,	"STYPE" "creeper", 	"SPECIAL" TableN("Payload" 1000, 1)	3 TableN
		GetMVersePlayerNum lt0 if "WEIGHT" 75.0,	"TYPE" "forb",		"SPECIAL" TableN("CountMin" 1, "CountMax" 2, "Height" 0, 3)	3 TableN endif
		GetMVersePlayerNum lt0 if "WEIGHT" 25.0,	"TYPE" "forb",		"SPECIAL" TableN("CountMin" 2, "CountMax" 3, "Height" 0, 3)	3 TableN endif
	endif
		<-G_tttltConf{"REGULAR_MYSTERY_BOX"}{"Types"}{"Bad"} AppendStackToList
		
	
	StackSize gt0 if
		"RNGManager.InitializeConfiguration ended with leftovers on the stack:" Print
		PrintStack
	endif
:InitializeLootData
	<-*MB_OptionDifficulty ->ild_difficulty
	CreateList ->ild_smallWorklist #worklists for sorting items later
	CreateList ->ild_largeWorklist 
	<-G_tttltConf GetTableKeys ->ild_lKeysRoot #object containing list of all boxes
	<-ild_lKeysRoot 0 do
		<-G_tttltConf{<-ild_lKeysRoot[I]} ->ild_currentBox #reference to current box
		<-ild_currentBox{"Types"} GetTableKeys ->ild_currentTypes #list of types for current box
		0.0 ->ild_totalTypeWeight #total of type weight for all types in this box
		0.0 ->ild_totalItemWeight #total of item weight for all types in this box
		0 ->ild_totalItemCount
		CreateList ->ild_typeWeightTotals #total of item weight in each individual type
		CreateList ->ild_scalingConstants #cached values used to scale probability of all items
		CreateList ->ild_combinedLoot #list of all loot for this box from all types
		
		<-ild_currentTypes 0 do
			<-ild_currentTypes[I] ->ild_currentType #string naming the current type
			0.0 ->ild_currentWeightTotal #current weight total for this type
			<-ild_currentBox{"Types"}{<-ild_currentType} ->ild_currentTypeLoot #reference to loot list for this type
			<-ild_currentBox{"TypeWeights"}{<-ild_difficulty}{<-ild_currentType} <-ild_totalTypeWeight add ->ild_totalTypeWeight
			<-ild_currentTypeLoot 0 do
				<-ild_currentTypeLoot[I]{"WEIGHT"} <-ild_currentWeightTotal add ->ild_currentWeightTotal
				<-ild_totalItemCount 1 add ->ild_totalItemCount
			loop
			<-ild_currentWeightTotal dup <-ild_totalItemWeight add ->ild_totalItemWeight #dup value carried to next line
			<-ild_typeWeightTotals[I] add ->ild_typeWeightTotals[I]
		loop
		
		#need to do another iteration since the weight total is needed for this part
		<-ild_currentTypes 0 do
			<-ild_currentTypes[I] ->ild_currentType #string naming the current type
			<-ild_currentBox{"TypeWeights"}{<-ild_difficulty}{<-ild_currentType} <-ild_totalItemCount mul 
			<-ild_totalTypeWeight <-ild_typeWeightTotals[I] mul div ->ild_currentScalingConstant
			<-ild_currentBox{"Types"}{<-ild_currentType} ->ild_currentTypeLoot #reference to loot list for this type
			<-ild_currentTypeLoot 0 do
				<-ild_currentTypeLoot[I] DeepCopy ->ild_currentLootObject
				<-ild_currentLootObject{"WEIGHT"} <-ild_currentScalingConstant mul ->ild_currentScaledWeight
				<-ild_currentScaledWeight ->ild_currentLootObject{"WEIGHT"}
				<-ild_combinedLoot GetListCount ->ild_currentLootIndex
				<-ild_combinedLoot <-ild_currentLootObject PushList
				<-ild_currentScaledWeight 1 lt if
					<-ild_smallWorklist <-ild_currentLootIndex PushList
				else
					<-ild_largeWorklist <-ild_currentLootIndex PushList
				endif
			loop
		loop
		
		<-ild_combinedLoot GetListCount dup CreateListStartingSize ->ild_adjustedProbList CreateListStartingSize ->ild_aliasList
		
		while <-ild_smallWorklist GetListCount gt0 <-ild_largeWorklist GetListCount gt0 and repeat
			<-ild_smallWorklist PopList ->ild_smallIndex
			<-ild_largeWorklist PopList ->ild_largeIndex
			<-ild_combinedLoot[<-ild_smallIndex] ->ild_smallItem
			<-ild_combinedLoot[<-ild_largeIndex] ->ild_largeItem
			<-ild_smallItem{"WEIGHT"} ->ild_adjustedProbList[<-ild_smallIndex]
			<-ild_largeIndex ->ild_aliasList[<-ild_smallIndex]
			<-ild_smallItem{"WEIGHT"} <-ild_largeItem{"WEIGHT"} add 1.0 sub dup ->ild_largeItem{"WEIGHT"} #dup value carried to next line
			1.0 lt if #value being compared is the adjusted weight dup'ed on the last line
					<-ild_smallWorklist <-ild_largeIndex PushList
				else
					<-ild_largeWorklist <-ild_largeIndex PushList
			endif
			
		endwhile
		
		while <-ild_largeWorklist GetListCount gt0 repeat
			<-ild_largeWorklist PopList ->ild_largeIndex
			1.0 ->ild_adjustedProbList[<-ild_largeIndex]
		endwhile
		
		while <-ild_smallWorklist GetListCount gt0 repeat
			<-ild_smallWorklist PopList ->ild_smallIndex
			1.0 ->ild_adjustedProbList[<-ild_smallIndex]
		endwhile
		
		<-ild_combinedLoot ->ild_currentBox{"CombinedLootList"}
		<-ild_aliasList ->ild_currentBox{"Aliases"}
		<-ild_adjustedProbList ->ild_currentBox{"AdjustedProb"}
		<-ild_totalItemCount ->ild_currentBox{"TotalItems"}	
	loop
	
# -
# Description: Generate a random seed for every box type in the config.
# Arguments: 
# Result: 
:SeedConfig 
	#Seed built-in RNG.
	ElapsedTime 10000 mod 0 do
		RandFloat pop 
	loop

	<-G_tttltConf GetTableKeys ->SCF_lKeysRoot #object containing list of all boxes
	<-SCF_lKeysRoot 0 do
		<-G_tttltConf{<-SCF_lKeysRoot[I]} ->SCF_currentBox
		
		#Generate seeds for configs.
		1 10000000 RandInt ->SCF_currentBox{"Seed"}
	loop
	
	
# s1 i1 i2 - i3
# Description: Generate a random integer between min (inclusive) or max (exclusive) using a box's current seed and increment the seed.
# Arguments: The name of the current box, min, max
# Result: Random int
:RandIntSeeded
	->RIS_iMaxExcl
	->RIS_iMinIncl
	@RandFloatSeeded ->RIS_iRand
	
	<-RIS_iMaxExcl <-RIS_iMinIncl sub <-RIS_iRand mul floor <-RIS_iMinIncl add

# s1 - f1
# Description: Generate a random float between 0 and 1 using a box's current seed and increment the seed.
# Arguments: The name of the current box
# Result: Random float
:RandFloatSeeded
	->RFS_sType
	
	<-G_tttltConf{<-RFS_sType}{"Seed"} ->RFS_iSeed
	<-RFS_iSeed sin 10000.0 mul ->RFS_fVal
	
	#Increment seed.
	<-G_tttltConf{<-RFS_sType} "Seed" <-RFS_iSeed 1 add SetTableElement
	
	<-RFS_fVal <-RFS_fVal floor sub

# _DATA -
# Description: MSG event handler for a mystery box opening event of the current player.
# Arguments: 
# Result: 
:OnMysteryBoxOpened
	<-_DATA{"sType"} <-_DATA{"v3fPos"} FALSE FALSE @_OnMysteryBoxOpened

# _DATA -
# Description: Mverse MSG event handler for a mystery box opening event from another player.
# Arguments: 
# Result: 
:OnMverseMysteryBoxOpened
	<-_DATA{"sType"} ->MMB_sType
	<-G_tttltConf{<-MMB_sType} ->MMB_ttltConfRoot
	
	#Backup current seed
	<-MMB_ttltConfRoot{"Seed"} ->MMB_iSeedBackup
	#Temporarily replace current seed with mverse seed
	<-_DATA{"Seed"} ->MMB_ttltConfRoot{"Seed"}
	
	#Open box
	<-MMB_sType <-_DATA{"v3fPos"} <-_DATA{"CounterOnly"} TRUE @_OnMysteryBoxOpened
	
	#Put back our seed
	<-MMB_iSeedBackup ->MMB_ttltConfRoot{"Seed"}
	
# s1 v3f b1 -
# Description: Processes a box opening event.
# Arguments: Box name, 3D position of the event, bool TRUE if event came from another player in mverse FALSE otherwise
# Result: 
:_OnMysteryBoxOpened
	->MBO_bIsFromMverse ->MBO_bIsCounterOnly ->MBO_v3fPos ->MBO_sType
	
	#Add to counter
	<-MBO_sType "REGULAR_MYSTERY_BOX" eq if
		<-*MB_MysteryBoxesOpened 1 add ->*MB_MysteryBoxesOpened
		@UpdateMysteryBoxOpenedButton
		@UpdateEvilMultiplierButton
	endif
	
	<-MBO_bIsCounterOnly if
		return
	endif
	
	NULL ->MBO_tChosenEntry #reference to selected loot object
	0 ->MBO_iStaggerFrames
	
	#####
	# Now things get fun
	
	#Titan box override
	<-MBO_sType "TITAN_MYSTERY_BOX" eq <-*MB_TitanGuaranteedBadCount 0 gt and GetEditMode not and if
		<-G_ltEvilTitan <-*MB_TitanGuaranteedBadCount 1 sub GetListElement ->MBO_tChosenEntry
		<-*MB_TitanGuaranteedBadCount 1 sub ->*MB_TitanGuaranteedBadCount
	endif
	
	#Regular behavior
	<-MBO_tChosenEntry IsNull if
		#Get current config.
		<-G_tttltConf{<-MBO_sType} ->MBO_ttltConfRoot
		<-MBO_ttltConfRoot{"Seed"} ->MBO_iSeedUsed
		<-MBO_ttltConfRoot{"CombinedLootList"} ->MBO_lootList
		
		#Roll for chance of spawning nothing.
		<-MBO_ttltConfRoot{"NothingChancePrc"} <-MBO_sType @RandFloatSeeded 100.0 mul gte if
			return
		endif
		
		
		
		<-MBO_sType 0 <-MBO_lootList GetListCount @RandIntSeeded ->MBO_selectedBucket #AdjustedProb Aliases
		<-MBO_sType @RandFloatSeeded <-MBO_ttltConfRoot{"AdjustedProb"}[<-MBO_selectedBucket] gte if
			<-MBO_ttltConfRoot{"Aliases"}[<-MBO_selectedBucket] ->MBO_selectedBucket
		endif
		<-MBO_lootList[<-MBO_selectedBucket] ->MBO_tChosenEntry
	endif
	
	
	#If for some reason (config misconfiguration) an event wasn't chosen, exit.
	<-MBO_tChosenEntry IsNull if
		"SELECTED NULL" Print
		return
	endif
	
	<-MBO_tChosenEntry{"TYPE"} ->MBO_sUnitType
	<-MBO_tChosenEntry{"SPECIAL"} ->MBO_tSpecial
	
	#Play effect, if any.
	<-MBO_tSpecial{"Effect"} "boom1" StartsWith if
		"explosion5" <-MBO_v3fPos 4 4 4 V3 CreateEffect
	else <-MBO_tSpecial{"Effect"} "boom2" StartsWith if
		"explosion5" <-MBO_v3fPos 8 8 8 V3 CreateEffect
	endif endif
	
	#Mverse stuff
	FALSE ->MBO_bMverseMessageSent
	GetMVersePlayerNum 0 gte if
		#Combine TYPE and STYPE
		<-MBO_sUnitType ->MBO_sMverseUnitType
		<-MBO_sMverseUnitType IsNull if
			<-MBO_tChosenEntry{"STYPE"} ->MBO_sMverseUnitType
		endif
		
		<-G_tbMversePlayerUnits{<-MBO_sMverseUnitType} not if
			<-MBO_bIsFromMverse not if
				"MB_MverseMysteryBoxOpened" "sType" <-MBO_sType "v3fPos" <-MBO_v3fPos "Seed" <-MBO_iSeedUsed 3 TableN SendMVerseMsg
				TRUE ->MBO_bMverseMessageSent
				
				<-G_tbMverseTypesSpawnForEveryone{<-MBO_sMverseUnitType} not if
					GetMVersePlayerNum 0 neq if return endif
				endif
			else
				#Only intercept messages as host.
				<-G_tbMverseTypesSpawnForEveryone{<-MBO_sMverseUnitType} not if
					GetMVersePlayerNum 0 neq if return endif
				endif
			endif
		endif
		<-MBO_bIsFromMverse not if
			<-MBO_bMverseMessageSent not if
				"MB_MverseMysteryBoxOpened" "sType" <-MBO_sType "v3fPos" <-MBO_v3fPos "Seed" <-MBO_iSeedUsed "CounterOnly" TRUE 4 TableN SendMVerseMsg
			endif
		endif
	endif
	
	<-MBO_tSpecial{"Count"} ->MBO_iCount
	<-MBO_tSpecial{"Height"} ->MBO_iHeight
	<-MBO_tSpecial{"CountMin"} ->MBO_iCountMin
	<-MBO_tSpecial{"CountMax"} ->MBO_iCountMax
	<-MBO_tSpecial{"Unselectable"} ->MBO_bUnselectable
	<-MBO_tSpecial{"Seed"} ->MBO_bSeed
	
	#If no count variables are present, amplify payloads
	<-MBO_sType "REGULAR_MYSTERY_BOX" eq if
		<-MBO_tSpecial{"ScaleHard"} IsNull not if
			<-MBO_tSpecial{"Count"} IsNull <-MBO_tSpecial{"CountMin"} IsNull and <-MBO_tSpecial{"CountMax"} IsNull and if
				<-*MB_MysteryBoxesOpened <-EvilMultiplierIncreasePerBox mul <-MBO_tSpecial{"ScaleHard"} mul 1 add ->MBO_fMult
			
				<-MBO_tChosenEntry{"SETTINGS"}{"Payload"} IsNull not if
					<-MBO_tChosenEntry{"SETTINGS"} "Payload" <-MBO_tChosenEntry{"SETTINGS"}{"Payload"} <-MBO_fMult mul 2000 min SetTableElement
				else <-MBO_tChosenEntry{"SPECIAL"}{"Payload"} IsNull not if
					<-MBO_tChosenEntry{"SPECIAL"} "Payload" <-MBO_tChosenEntry{"SPECIAL"}{"Payload"} <-MBO_fMult mul SetTableElement
				endif endif
			endif
		endif
	endif
	
	#Process special event behaviors.
	<-MBO_sType <-MBO_tChosenEntry <-MBO_v3fPos <-MBO_bIsFromMverse @ProcessSpecialBoxSpawnBehaviors
	
	#These are types that should avoid default behavior in favor of special behavior.
	#Past this point, we are guaranteed to create some units using default behavior.
	<-MBO_sUnitType IsNull if
		return
	endif
	
	#Process CountMin and CountMax, add them to Count.
	<-MBO_iCountMin IsNull not <-MBO_iCountMax IsNull not and if
		<-MBO_iCount IsNull if
			0 ->MBO_iCount
		endif
		<-MBO_sType <-MBO_iCountMin <-MBO_iCountMax 1 add @RandIntSeeded <-MBO_iCount add ->MBO_iCount
	endif
	
	#If no count was determined, default to 1.
	<-MBO_iCount IsNull <-MBO_iCount 0 lte or if
		1 ->MBO_iCount
	endif
	
	#Amplify by scale
	<-MBO_sType "REGULAR_MYSTERY_BOX" eq if
		<-MBO_tSpecial{"ScaleHard"} IsNull not if
			<-*MB_MysteryBoxesOpened <-EvilMultiplierIncreasePerBox mul <-MBO_tSpecial{"ScaleHard"} mul 1 add ->MBO_fMult
		
			<-MBO_tSpecial{"Count"} IsNull not
			<-MBO_tSpecial{"CountMin"} IsNull not <-MBO_tSpecial{"CountMax"} IsNull not and or if
				<-MBO_fMult <-MBO_iCount mul asint ->MBO_iCount
			endif
		endif
	endif
	
	
	#Generate a list of positions to create the units that are to be spawned.
	CreateList ->MBO_lfSpawnPositions
	<-MBO_iCount 1 eq if
		<-MBO_v3fPos.x <-MBO_v3fPos.z <-MBO_lfSpawnPositions AppendStackToList
	else <-MBO_iCount 2 eq if
		<-MBO_v3fPos.x <-MBO_v3fPos.z 2 add <-MBO_v3fPos.x <-MBO_v3fPos.z 2 sub <-MBO_lfSpawnPositions AppendStackToList
	else <-MBO_iCount 3 eq if
			<-MBO_v3fPos.x 2 add <-MBO_v3fPos.z 2 add 
			<-MBO_v3fPos.x 2 sub <-MBO_v3fPos.z 2 add 
			<-MBO_v3fPos.x <-MBO_v3fPos.z 2 sub
		<-MBO_lfSpawnPositions AppendStackToList
	else <-MBO_iCount 4 eq if
			<-MBO_v3fPos.x 2 add <-MBO_v3fPos.z 2 add 
			<-MBO_v3fPos.x 2 sub <-MBO_v3fPos.z 2 add 
			<-MBO_v3fPos.x 2 add <-MBO_v3fPos.z 2 sub
			<-MBO_v3fPos.x 2 sub <-MBO_v3fPos.z 2 sub
		<-MBO_lfSpawnPositions AppendStackToList
	else
		<-MBO_iCount 0 do
			<-MBO_sType @RandFloatSeeded 6.0 mul <-MBO_v3fPos.x 3 sub add
				<-MBO_sType @RandFloatSeeded 6.0 mul <-MBO_v3fPos.z 3 sub add
			<-MBO_lfSpawnPositions AppendStackToList
		loop
	endif endif endif endif
	
	#Use seeded random for spores and blobs.
	NULL ->MBO_tSeededSettingsTable
	<-MBO_tChosenEntry{"SETTINGS"}{"Target"} eq0 if
		<-MBO_tChosenEntry{"TYPE"} "spore" eq
		<-MBO_tChosenEntry{"TYPE"} "blob" eq or if
			#If we're making spores or blobs with random targeting, create a copy of the settings table
			#and flip Target from 0 to 2. Then we will random our own position later during creation of the unit
			CreateTable ->MBO_tSeededSettingsTable
			GetMapSize ->MBO_iMapSizeZ ->MBO_iMapSizeX
			<-MBO_tChosenEntry{"SETTINGS"} GetTableKeys ->MBO_tKeys
			<-MBO_tKeys 0 do
				<-MBO_tSeededSettingsTable <-MBO_tKeys[I] <-MBO_tChosenEntry{"SETTINGS"}{<-MBO_tKeys[I]} SetTableElement
			loop
			<-MBO_tSeededSettingsTable "Target" 2 SetTableElement
		endif
	endif
	
	
	#Create the unit(s).
	0 ->MBO_iI
	while <-MBO_iI <-MBO_lfSpawnPositions GetListCount lt repeat
		<-MBO_lfSpawnPositions[<-MBO_iI 1 add] ->MBO_fPosX
		<-MBO_lfSpawnPositions[<-MBO_iI] ->MBO_fPosZ
		
		#Random a target location if needed
		<-MBO_tSeededSettingsTable IsNull not if
			<-MBO_tSeededSettingsTable "TargetLocation"
				<-MBO_sType 0 <-MBO_iMapSizeX @RandIntSeeded
				<-MBO_sType 0 <-MBO_iMapSizeZ @RandIntSeeded
			V2 SetTableElement
			<-MBO_tSeededSettingsTable ->MBO_tSettingsTable
		else
			<-MBO_tChosenEntry{"SETTINGS"} ->MBO_tSettingsTable
		endif
		<-MBO_tSettingsTable IsNull if
			CreateTable ->MBO_tSettingsTable
		endif
		
		<-MBO_sUnitType <-*MB_tCustomGUIDs{"Mystery Box"} eq if
			<-MBO_iStaggerFrames 5 add ->MBO_iStaggerFrames
			<-MBO_tSettingsTable "StaggerFrames" <-MBO_iStaggerFrames SetTableElement
		endif
		
		<-MBO_iHeight IsNull if
			<-MBO_tChosenEntry{"TYPE"} <-MBO_fPosX <-MBO_fPosZ <-MBO_tSettingsTable CreateUnitOnTerrain ->MBO_iUID
			<-MBO_iUID <-MBO_sType <-MBO_tChosenEntry <-MBO_fPosX 0 <-MBO_fPosZ V3 @ProcessSpecialUnitSpawnBehaviors
		else
			<-MBO_fPosX <-MBO_v3fPos.y <-MBO_iHeight add <-MBO_fPosZ V3 ->MBO_v3fPosUnit
			<-MBO_tChosenEntry{"TYPE"} <-MBO_v3fPosUnit <-MBO_tSettingsTable CreateUnit ->MBO_iUID
			<-MBO_iUID <-MBO_sType <-MBO_tChosenEntry <-MBO_v3fPosUnit @ProcessSpecialUnitSpawnBehaviors
		endif
		
		#Make blobs drop additional creeper when they die
		GetMVersePlayerNum 0 lte <-MBO_iUID GetUnitType "blob" eq and if
			<-*G_lBlobsDestruction "uid" <-MBO_iUID "payload" <-MBO_iUID GetUnitSettings "Payload" GetTableElement 2 TableN AppendToList
		endif
		
		#If we're in mverse and this is a shared unit, stagger its construction.
		GetMVersePlayerNum 0 gte <-*MB_tbMverseSharedUnits{<-MBO_tChosenEntry{"TYPE"}} and if
			#Do not lower the stagger frames. It will go wrong at higher game speeds.
			<-MBO_iUID @MverseRegisterSharedUnit
		else
			<-MBO_iUID 9999 ConstructUnit
		endif
		
		#If this is a nullifiable enemy, register it to sync destruction.
		GetMVersePlayerNum 0 gte <-G_tbMverseNullifiableEnemies{<-MBO_tChosenEntry{"TYPE"}} and if
			#Do nothing if this is an AC emitter as it cannot be nullified.
			<-MBO_tChosenEntry{"TYPE"} "emitter" eq <-MBO_tChosenEntry{"SETTINGS"}{"Payload"} 0 lt and if
				0 pop
			else
				<-MBO_iUID @MverseRegisterUnitSyncDestruction
			endif
		endif
		
		<-MBO_iUID <-MBO_sType <-MBO_tChosenEntry <-MBO_v3fPosUnit @ProcessUnitAmmoBehaviors
		<-MBO_bUnselectable if
			<-MBO_iUID FALSE SetUnitSelectable
		endif
		<-MBO_bSeed if
			<-MBO_iUID "" "Seed" <-MBO_sType 1 10000000 @RandIntSeeded SetScriptVar
		endif
		
		<-MBO_iI 2 add ->MBO_iI
	endwhile
	
	StackSize gt0 if
		"RNGManager.OnMysteryBoxOpened ended with leftovers on the stack:" Print
		PrintStack
	endif

# i1 - 
# Description: Register a unit as one that should sync its destruction with other players.
# Arguments: UID of the unit
# Result: 
:MverseRegisterUnitSyncDestruction
	->MRE_iUID
	<-MRE_iUID GetUnitCell ->MRE_iPosZ ->MRE_iPosX
	
	<-G_ltMverseUnitsToSyncDestruction
		"iUID" <-MRE_iUID
		"sType" <-MRE_iUID GetUnitType
		"iPosX" <-MRE_iPosX
		"iPosZ" <-MRE_iPosZ
	4 TableN AppendToList

# i1 - 
# Description: Register a Mverse shared unit. These units have staggered construction due to a game bug.
# Arguments: UID of the unit
# Result: 
:MverseRegisterSharedUnit
	->MRS_iUID

	<-G_ltMverseSharedUnitsToConstruct "UID" <-MRS_iUID "StaggerFrames" 10 2 TableN AppendToList
	
# _DATA -
# Description: Mverse MSG that comes in whenever a synced unit is destroyed.
# Arguments:
# Result: 
:OnMverseSyncedUnitDestroyed
	<-_DATA{"sType"} <-_DATA{"iPosX"} 0 <-_DATA{"iPosZ"} V3 0 0 0 0 0 0 0 GetUnits ->OME_lUnits
	#Find the first one, destroy it. Good enough
	<-OME_lUnits 0 do
		<-OME_lUnits[I] 0 0 0 DestroyUnit
		break
	loop

# i1 s1 t1 v3f -
# Description: Determine the created unit's initial ammo count. Units are set to full ammo by default, but this can be overridden.
# Arguments: Unit UID, Box name, config entry, unit 3D position
# Result: 
:ProcessUnitAmmoBehaviors
	->PS_v3fPos
	->PS_tEntry
	->PS_sType
	->PS_iUID
	
	<-PS_tEntry{"TYPE"} ->PS_s
	
	<-PS_s "shield" eq
	<-PS_s <-*MB_tCustomGUIDs{"Airship"} eq or
	<-PS_s <-*MB_tCustomGUIDs{"Sweeper"} eq or 
	<-PS_s <-*MB_tCustomGUIDs{"Wallis"} eq or
	<-PS_s <-*MB_tCustomGUIDs{"ERNMaker"} eq or if
		<-PS_iUID 0 SetUnitAmmo
	else
		<-PS_iUID dup GetUnitMaxAmmo SetUnitAmmo
	endif 

# s1 t2 v3f3 -
# Description: Determine the created unit's special behaviors.
# Arguments: Box name, config entry, unit 3D position
# Result: 
:ProcessSpecialUnitSpawnBehaviors
	->PS_v3fPos
	->PS_tEntry
	->PS_sType
	->PS_iUID
	
	<-PS_tEntry{"TYPE"} ->PS_s
	
	<-PS_s "crystal" eq if
		<-PS_v3fPos.z 2 add <-PS_v3fPos.z 1 sub do
			<-PS_v3fPos.x 2 add <-PS_v3fPos.x 1 sub do
				<-PS_sType @RandFloatSeeded 0.5 lte if
					I J 9 SetTerrainSpecial
				endif
			loop
		loop
	else <-PS_s "pod" eq if
		<-PS_iUID TRUE SetUnitSelectable
		<-PS_iUID TRUE SetUnitSelected
		<-PS_iUID TRUE SetUnitConnectable
		<-PS_iUID TRUE SetUnitOccupiesLand
	endif endif
	
# s1 t2 v3f3 - 
# Description: Determine the created box spawn behaviors. This handles special occurrences that do not use the default unit spawning mechanism.
#              Because of this, many normally automated behaviors have to be defined manually.
# Arguments: Box name, config entry, unit 3D position, TRUE if from another player FALSE if from current player
# Result: 
:ProcessSpecialBoxSpawnBehaviors
	->PS_bIsFromMverse
	->PS_v3fPos
	->PS_tEntry
	->PS_sType
	
	<-PS_tEntry{"STYPE"} ->PS_s
	
	<-PS_s "creeper" eq if
		<-PS_tEntry{"SPECIAL"}{"Payload"} ->PS_fPayload
		<-PS_tEntry{"SPECIAL"}{"Fakeout"} ->PS_bFakeout
		
		GetMversePlayerNum 0 lte if
			FALSE ->PS_bIsAC
			<-PS_fPayload 0 lt if
				TRUE ->PS_bIsAC
			endif
			<-PS_fPayload abs ->PS_fPayload
			
			<-PS_fPayload 2000 49 mul gte if
				4 ->PS_iRadius
				<-PS_fPayload 81.0 div ->PS_fPayload
			else <-PS_fPayload 2000 25 mul gte if
				3 ->PS_iRadius
				<-PS_fPayload 49.0 div ->PS_fPayload
			else <-PS_fPayload 2000 9 mul gte if
				2 ->PS_iRadius
				<-PS_fPayload 25.0 div ->PS_fPayload
			else <-PS_fPayload 2000 1 mul gte if
				1 ->PS_iRadius
				<-PS_fPayload 9.0 div ->PS_fPayload
			else
				0 ->PS_iRadius
			endif endif endif endif
			
			<-PS_bIsAC if
				<-PS_fPayload -1 mul ->PS_fPayload
			endif
			
			<-PS_v3fPos.z <-PS_iRadius add 1 add <-PS_v3fPos.z <-PS_iRadius sub do
				<-PS_v3fPos.x <-PS_iRadius add 1 add <-PS_v3fPos.x <-PS_iRadius sub do
					I J <-PS_fPayload AddCreeper
				loop
			loop
		endif
		
		<-PS_bFakeout if
			<-*MB_tCustomGUIDs{"Titan Fake-Out"} <-PS_v3fPos "Seed" <-PS_sType 0 10000000 @RandIntSeeded, 1 TableN CreateUnit
		endif
	else <-PS_s "u_wall" eq if
		<-PS_tEntry{"SPECIAL"}{"Type"} ->PS_sWallType
	
		<-PS_v3fPos.z 3 add ->PS_iZTop
		<-PS_v3fPos.z 3 sub ->PS_iZBottom
		<-PS_v3fPos.x 3 add ->PS_iXRight
		<-PS_v3fPos.x 3 sub ->PS_iXLeft
	
		<-PS_sType 0 4 @RandIntSeeded ->PS_iEmptySide
		
		<-PS_iZTop 1 add <-PS_iZBottom do
			<-PS_iXRight 1 add <-PS_iXLeft do
				<-PS_iEmptySide 0 eq J <-PS_iZTop eq J <-PS_iZBottom eq I <-PS_iXRight eq or or and 
				<-PS_iEmptySide 1 eq J <-PS_iZTop eq J <-PS_iZBottom eq I <-PS_iXLeft eq or or and or
				<-PS_iEmptySide 2 eq I <-PS_iXLeft eq I <-PS_iXRight eq J <-PS_iZTop eq or or and or
				<-PS_iEmptySide 3 eq I <-PS_iXLeft eq I <-PS_iXRight eq J <-PS_iZBottom eq or or and or if
					<-PS_sWallType I J NULL CreateUnitOnTerrain pop
				endif
			loop
		loop
	else <-PS_s "skimmer_fortress" eq if
		<-PS_tEntry{"SPECIAL"}{"CrimsonTowers"} ->PS_bCrimsonTowers
		
		GetMVersePlayerNum 0 lte if
			18 ->PS_iCircleRadius
			<-PS_iCircleRadius 1 add <-PS_iCircleRadius neg do
				<-PS_iCircleRadius 1 add <-PS_iCircleRadius neg do
					#In a circle
					I I mul J J mul add <-PS_iCircleRadius dup mul lt if
						I <-PS_v3fPos.x add J <-PS_v3fPos.z add GetCreeper 0 lt if
							I <-PS_v3fPos.x add J <-PS_v3fPos.z add 0 0 SetCreeper
						endif
					endif
				loop
			loop
		
			<-PS_v3fPos.z 2 add <-PS_v3fPos.z 1 sub do
				<-PS_v3fPos.x 2 add <-PS_v3fPos.x 1 sub do
					I J 1111 AddCreeper
				loop
			loop
		endif
	
		10 0 do
			"skimmer" <-PS_v3fPos.x <-PS_v3fPos.y 15 add <-PS_v3fPos.z V3 "Target" 0 "LifeTime" 140 2 TableN CreateUnit pop
		loop
		
		ClearStack
		"skimmerfactory" <-PS_v3fPos.x <-PS_v3fPos.z "Start" 0 "Count" 10 2 TableN CreateUnitOnTerrain
		"blobnest" <-PS_v3fPos.x <-PS_v3fPos.z 2 add "Start" 0 "Interval" 900 "Target" 0 "Payload" 1500 4 TableN CreateUnitOnTerrain
		"blobnest" <-PS_v3fPos.x <-PS_v3fPos.z 2 sub "Start" 0 "Interval" 900 "Target" 0 "Payload" 1500 4 TableN CreateUnitOnTerrain
		"emitter" <-PS_v3fPos.x 2 add <-PS_v3fPos.z "Payload" 75 1 TableN CreateUnitOnTerrain
		"emitter" <-PS_v3fPos.x 2 sub <-PS_v3fPos.z "Payload" 75 1 TableN CreateUnitOnTerrain
		List ->PS_lUnits
		
		GetMVersePlayerNum 0 gte if
			<-PS_lUnits 0 do
				<-PS_lUnits[I] @MverseRegisterUnitSyncDestruction
			loop
		endif
		
		<-PS_bCrimsonTowers if
			"crystal" <-PS_v3fPos.x 1 add <-PS_v3fPos.z 2 add NULL CreateUnitOnTerrain pop
			"crystal" <-PS_v3fPos.x 1 sub <-PS_v3fPos.z 2 add NULL CreateUnitOnTerrain pop
			"crystal" <-PS_v3fPos.x 1 add <-PS_v3fPos.z 2 sub NULL CreateUnitOnTerrain pop
			"crystal" <-PS_v3fPos.x 1 sub <-PS_v3fPos.z 2 sub NULL CreateUnitOnTerrain pop
		endif
		
		<-PS_v3fPos.z 6 add <-PS_v3fPos.z 5 sub do
			<-PS_v3fPos.x 6 add <-PS_v3fPos.x 5 sub do
				I J 6 SetTerrainSpecial 
			loop
		loop
	else <-PS_s "orbital_factory" eq if
		<-PS_bIsFromMverse not if
			"rocketpad" <-PS_v3fPos.x <-PS_v3fPos.z 0 CreateUnitOnTerrain dup FALSE SetUnitDamagedByCreeper 9999 ConstructUnit
			
			ClearStack
			"greenarrefinery" <-PS_v3fPos.x 1 add <-PS_v3fPos.z 0 CreateUnitOnTerrain dup V3(0 180 0) SetUnitRotation
			"greenarrefinery" <-PS_v3fPos.x 1 sub <-PS_v3fPos.z 0 CreateUnitOnTerrain dup V3(0 0 0) SetUnitRotation
			"greenarrefinery" <-PS_v3fPos.x <-PS_v3fPos.z 1 add 0 CreateUnitOnTerrain dup V3(0 90 0) SetUnitRotation
			"greenarrefinery" <-PS_v3fPos.x <-PS_v3fPos.z 1 sub 0 CreateUnitOnTerrain dup V3(0 270 0) SetUnitRotation
			List ->PS_lRefineries
			
			GetMVersePlayerNum 0 gte if
				<-PS_lRefineries 0 do
					<-PS_lRefineries[I] @MverseRegisterSharedUnit
				loop
			else
				<-PS_lRefineries 0 do
					<-PS_lRefineries[I] 9999 ConstructUnit
				loop
			endif
		endif
	
		"greenarmother" <-PS_v3fPos.x <-PS_v3fPos.z "Interval" 60 1 TableN CreateUnitOnTerrain pop
	else <-PS_s "solar_farm" eq if
		6 0 do
			"collectorpanel5" <-PS_v3fPos.x <-PS_v3fPos.z NULL CreateUnitOnTerrain @MverseRegisterUnitSyncDestruction
		loop
		"collectorpanel3" <-PS_v3fPos.x 1 sub <-PS_v3fPos.z 2 sub NULL CreateUnitOnTerrain @MverseRegisterUnitSyncDestruction
	
	else <-PS_s "miner_res" eq if
		<-PS_tEntry{"SPECIAL"}{"Coverage"} 100.0 div ->PS_fCoverage
		<-PS_tEntry{"SPECIAL"}{"SpawnTwo"} ->PS_bSpawnTwo
		
		<-PS_bSpawnTwo if
			<-PS_sType 0 2 @RandIntSeeded ->PS_bSpawnTwo
		endif
		
		CreateList ->PS_lMiners
		
		<-PS_bSpawnTwo not if
			GetMVersePlayerNum 0 lte if
				<-PS_lMiners "miner" <-PS_v3fPos.x <-PS_v3fPos.z 0 CreateUnitOnTerrain AppendToList
			endif
			
			<-PS_v3fPos.z 2 add <-PS_v3fPos.z 1 sub do
				<-PS_v3fPos.x 3 add <-PS_v3fPos.x 2 sub do
					<-PS_sType @RandFloatSeeded <-PS_fCoverage lte if
						I J 1 SetTerrainSpecial
					endif
				loop
			loop
		else
			GetMVersePlayerNum 0 lte if
				<-PS_lMiners "miner" <-PS_v3fPos.x <-PS_v3fPos.z 2 add 0 CreateUnitOnTerrain AppendToList
				<-PS_lMiners "miner" <-PS_v3fPos.x <-PS_v3fPos.z 2 sub 0 CreateUnitOnTerrain AppendToList
			endif
			
			<-PS_v3fPos.z 4 add <-PS_v3fPos.z 3 sub do
				<-PS_v3fPos.x 3 add <-PS_v3fPos.x 2 sub do
					<-PS_sType @RandFloatSeeded <-PS_fCoverage lte if
						I J 1 SetTerrainSpecial
					endif
				loop
			loop
		endif
		
		GetMVersePlayerNum 0 gte if
			<-PS_lMiners 0 do
				<-PS_lMiners[I] @MverseRegisterSharedUnit
			loop
		else
			<-PS_lMiners 0 do
				<-PS_lMiners[I] 9999 ConstructUnit
			loop
		endif
	else <-PS_s "bertha_combo" eq if
		CreateList ->PS_lBerthas
		
		"ern" <-PS_v3fPos.x 2 sub <-PS_v3fPos.y 3 add <-PS_v3fPos.z 2 sub V3 0 CreateUnit pop
		"ern" <-PS_v3fPos.x 2 add <-PS_v3fPos.y 3 add <-PS_v3fPos.z 2 add V3 0 CreateUnit pop
		"ern" <-PS_v3fPos.x 2 sub <-PS_v3fPos.y 3 add <-PS_v3fPos.z 2 add V3 0 CreateUnit pop
		"ern" <-PS_v3fPos.x 2 add <-PS_v3fPos.y 3 add <-PS_v3fPos.z 2 sub V3 0 CreateUnit pop
		
		<-PS_lBerthas <-*MB_tCustomGUIDs{"Bertha"} <-PS_v3fPos.x 2 sub <-PS_v3fPos.z 2 sub 0 CreateUnitOnTerrain AppendToList
		<-PS_lBerthas <-*MB_tCustomGUIDs{"Bertha"} <-PS_v3fPos.x 2 add <-PS_v3fPos.z 2 add 0 CreateUnitOnTerrain AppendToList
		<-PS_lBerthas <-*MB_tCustomGUIDs{"Bertha"} <-PS_v3fPos.x 2 sub <-PS_v3fPos.z 2 add 0 CreateUnitOnTerrain AppendToList
		<-PS_lBerthas <-*MB_tCustomGUIDs{"Bertha"} <-PS_v3fPos.x 2 add <-PS_v3fPos.z 2 sub 0 CreateUnitOnTerrain AppendToList
		
		<-PS_lBerthas 0 do
			<-PS_lBerthas[I] 9999 ConstructUnit
			<-PS_lBerthas[I] dup GetUnitMaxAmmo SetUnitAmmo
			<-PS_lBerthas[I] "" "Seed" <-PS_sType 1 10000000 @RandIntSeeded SetScriptVar
		loop
	else <-PS_s "contaminant_bomb" eq if
		<-PS_tEntry{"SPECIAL"}{"Range"} ->PS_iRange
		
		<-PS_v3fPos.x <-PS_iRange add 1 add <-PS_v3fPos.x <-PS_iRange sub do
			<-PS_v3fPos.z <-PS_iRange add 1 add <-PS_v3fPos.z <-PS_iRange sub do
				<-PS_sType @RandFloatSeeded ->PS_fRandFloat
			
				J I GetTerrain 0 gt if
					J J I GetTerrain I V3 <-PS_v3fPos Distance ->PS_fDistance
					<-PS_fDistance <-PS_iRange lte if
						<-PS_iRange 3.0 div ->PS_fPow
						<-PS_fDistance <-PS_fPow div ->PS_fChance
						#fix div by 0
						<-PS_fChance neq0 if
							1.0 <-PS_fChance div ->PS_fChance
						endif
						
						<-PS_fRandFloat, 1 <-PS_fChance sub gt if
							J I 8 SetTerrainSpecial
						endif
					endif
				endif
			loop
		loop
	else <-PS_s "smiley_face" eq if
		<-PS_v3fPos.x <-PS_v3fPos.z 20 SetTerrain
		
		<-PS_v3fPos.x 2 sub <-PS_v3fPos.z 1 add dup2 GetTerrain 1 add SetTerrain
		<-PS_v3fPos.x 3 sub <-PS_v3fPos.z 1 add dup2 GetTerrain 1 add SetTerrain
		<-PS_v3fPos.x 2 sub <-PS_v3fPos.z 2 add dup2 GetTerrain 1 add SetTerrain
		<-PS_v3fPos.x 3 sub <-PS_v3fPos.z 2 add dup2 GetTerrain 1 add SetTerrain
		
		<-PS_v3fPos.x 2 add <-PS_v3fPos.z 1 add dup2 GetTerrain 1 add SetTerrain
		<-PS_v3fPos.x 3 add <-PS_v3fPos.z 1 add dup2 GetTerrain 1 add SetTerrain
		<-PS_v3fPos.x 2 add <-PS_v3fPos.z 2 add dup2 GetTerrain 1 add SetTerrain
		<-PS_v3fPos.x 3 add <-PS_v3fPos.z 2 add dup2 GetTerrain 1 add SetTerrain
		
		<-PS_v3fPos.x 2 sub <-PS_v3fPos.z 1 sub dup2 GetTerrain 1 add SetTerrain
		<-PS_v3fPos.x 2 add <-PS_v3fPos.z 1 sub dup2 GetTerrain 1 add SetTerrain
		<-PS_v3fPos.x 2 sub <-PS_v3fPos.z 2 sub dup2 GetTerrain 1 add SetTerrain
		<-PS_v3fPos.x 2 add <-PS_v3fPos.z 2 sub dup2 GetTerrain 1 add SetTerrain
		<-PS_v3fPos.x 1 sub <-PS_v3fPos.z 2 sub dup2 GetTerrain 1 add SetTerrain
		<-PS_v3fPos.x 1 add <-PS_v3fPos.z 2 sub dup2 GetTerrain 1 add SetTerrain
		<-PS_v3fPos.x 1 sub <-PS_v3fPos.z 3 sub dup2 GetTerrain 1 add SetTerrain
		<-PS_v3fPos.x 1 add <-PS_v3fPos.z 3 sub dup2 GetTerrain 1 add SetTerrain
		<-PS_v3fPos.x <-PS_v3fPos.z 2 sub dup2 GetTerrain 1 add SetTerrain
		<-PS_v3fPos.x <-PS_v3fPos.z 3 sub dup2 GetTerrain 1 add SetTerrain
	else <-PS_s "breeder_hell" eq if
		<-PS_tEntry{"SPECIAL"}{"Range"} ->PS_iRange
		
		<-PS_v3fPos.x <-PS_iRange add 1 add <-PS_v3fPos.x <-PS_iRange sub do
			<-PS_v3fPos.z <-PS_iRange add 1 add <-PS_v3fPos.z <-PS_iRange sub do
				<-PS_sType @RandFloatSeeded ->PS_fRandFloat
				J J I GetTerrain I V3 <-PS_v3fPos Distance ->PS_fDistance
				<-PS_fDistance <-PS_iRange lte if
					<-PS_iRange 4.5 div ->PS_fPow
					<-PS_fDistance <-PS_fPow div ->PS_fChance
					#fix div by 0
					<-PS_fChance neq0 if
						1.0 <-PS_fChance div ->PS_fChance
					endif
				
					<-PS_fRandFloat, 1 <-PS_fChance sub gt if
						J I 2 SetTerrainSpecial
						GetMVersePlayerNum 0 lte if
							J I 5 TRUE SetCreeper
						endif
					endif
				endif
			loop
		loop
	else <-PS_s "creeper_cover" eq if 
		GetMapSize ->PS_iZ ->PS_iX
		<-PS_iZ 0 do
			<-PS_iX 0 do
				<-PS_sType @RandFloatSeeded 0.0025 lte if
					I J 1000 AddCreeper
				endif
			loop
		loop
	endif endif endif endif endif endif endif endif endif endif endif
:ResDivFactor
	0 ->RDF_iDivFactor
	GetMVersePlayers ->RDF_lPlayers
	<-RDF_lPlayers 0 do
		<-RDF_lPlayers[I] IsNull not if
			<-RDF_iDivFactor 1 add ->RDF_iDivFactor
		endif
	loop
	
	<-RDF_iDivFactor 1 max asfloat
:UpdateMysteryBoxOpenedButton
	1 TRUE "Mystery Boxes Opened: " <-*MB_MysteryBoxesOpened concat 1 0.8 0.05 1.0 V4 null null SetMSGButton
:UpdateEvilMultiplierButton
	<-*MB_OptionDifficulty "hard" eq if
		2 TRUE "Evil Multiplier:
" <-*MB_MysteryBoxesOpened <-EvilMultiplierIncreasePerBox mul 1 add concat 1.0 0.3 0.3 1.0 V4 null null SetMSGButton
	endif
	