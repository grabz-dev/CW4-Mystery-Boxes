# --RocketLauncher-- 11/17/2020 11:34:58 PM
#Created by Alophox
#everything is based off of the invasion map Berthas, with no 4RPL documentation available
#as such, many errors are bound to be here
#variable names are NOT changed overly much so as to maintain consistency, when appropriate, for clarity when reading either script.

$projSpeed:.4 #total speed
$rotSpeed:1 #radians per second
$fireCost:10
$rechargeTime:180 #frames between bursts
$miniRechargeTime:10.0 #frames between shots, makes sure it is a float
$DAMAGE_MESH:0.35
$DAMAGE_DIST:7 #presumably the radius of the damage
$DAMAGE_DEPTH:4 #presumably the depth from point of impact. Think of it as the Y radius
$$rocketShotGUID:"b28f91a8-b36a-4db1-8176-4f13dd2cdb71" #the GUID of the OBJECT. If you're familiar with Unity, think of it like a prefab. I don't know if two $$ is necessary, so I'm leaving it just in case
														#this can be found in the editor when selecting the object in question, in the package manager.
#if a unit isn't built, don't do anything
if (GetUnitConstructing(self))
	return
endif
Self GetUnitStunCount 0 gt if
	return
endif

Self GetUnitRangeWithMods ->currentUnitRange
<-currentUnitRange <-lastUnitRange neq if
	Self RefreshUnitLosCache
endif
<-currentUnitRange ->lastUnitRange



#SetUnitDebugText(self <-target)

if(<-burstCounter -1 !=)
	if(<-burstCounter <-miniRechargeTime mod 0 eq)
		if(<-burstCounter 0 ==)
			V3(.5 <-launchAngle HALFPI + cos *, .45, .5 <-launchAngle HALFPI + sin *) ->offset
			@FireProjectile(<-offset)
			
			#clear target
			V3(-1, -1, -1) ->target
		else
			V3(0, .45, 0) ->offset
			@FireProjectile(<-offset)
		endif
	endif
	<-burstCounter 1 - ->burstCounter
endif

@Refresh
if (GetUnitEnabled(self) GetUnitArmed(self) &&)
	if(<-moving !)
		if(<-fireCount gt0)
			<-fireCount 1 - ->fireCount
		else
			if (<-target.x gte0)
				#Tag the damage map with the damage this shot will do. When the shot is fire we will clean up the damage map, and let each shot set its own damage map data.
				#We apply this to ourselves in case we get destroyed before we shoot -KC
				ApplyToDamageMap(self <-autoTargetX <-autoTargetZ <-DAMAGE_DIST <-DAMAGE_DEPTH 1000000 * false)
				
				RotateObjTowardsCell(self "Rocket Pole" <-target.X <-target.Z <-rotSpeed Self GetUnitERNState if 2.0 mul endif)
				<-target.z <-currentPos.z - <-target.x <-currentPos.x - atan2 ->launchAngle
				
				GetObjFacingAngleCell(self "Rocket Pole" <-target.x <-target.z) ->facingAngle
				if (<-facingAngle .5 lt)
					@Fire
				endif	
			else if(@CanFire)
				#until I can figure out a "creeper within range" command, this will have to do.
				#GetMaxCreeperCellWithDamage ->autoTargetZ ->autoTargetX
				#found a command in the Thor.4rpl script
				#unfortunately this does NOT account for ERNs as far as I can tell
				FindUnitEnemy(self true 0) ->autoTargetZ ->autoTargetX #i believe the true is for deepest creeper in (closest if false), no idea what the 0 is for. Probably special targeting? 1 being snipable objects?
				SetUnitSpecifiedTarget(self V3(<-autoTargetX GetExactTerrain(<-autoTargetX <-autotargetZ false) <-autoTargetZ)) #V3 is Vector3. Common uses: <R,G,B> or <x,y,z>
				
				#For debugging purposes, here. Shows unit fire path, sorta.
				#SetUnitSpecifiedTargetShowPath(self true)
				
				SetUnitSpecifiedTargetShowPath(self false)
				GetUnitSpecifiedTarget(self) ->target
				if(<-target.x gte0 !)
					ClearUnitSpecifiedTarget(self)
				endif
				GetUnitPosition(self) ->currentPos
			endif endif
		endif	
	endif
endif

#makes sure things are up to date, such as LOS and movement
:Refresh
	if (Self GetUnitMoveCell pop -1 neq )
		1 ->moving
		#SetUnitDebugText(self "moving")
	else
		#SetUnitDebugText(self "")
		#we stopped moving, so refresh LOS
		if(<-moving)
			RefreshUnitLOSCache(self)
		endif
		0 ->moving #because we're not moving(even through 4rpl means)
	endif


#returns a boolean
#we have no cooldown AND we have enough ammo
:CanFire
	<-fireCount eq0 GetUnitAmmo(self) <-fireCost gte &&

#does internal if able to fire checks, as well as handling what happens when you can fire
:Fire
	if(@CanFire)
		#Remove any damage map that was set by auto targeting.
		#Each shot will set its own damage map data -KC
		RemoveUnitDamageMap(self)
		
		GetERNPortalEfficiency(5) ->ERNefficiency
		<-ERNefficiency 50.0 mul asint ->fireRateAdditionalCoefficient
	
		#reset cooldown
		<-rechargeTime <-fireRateAdditionalCoefficient sub ->fireCount
		
		#deduct cost
		self GetUnitAmmo(self) <-fireCost - SetUnitAmmo
		
		#this is the coolest thing ever.
		#initParams will store a table that will have ALL variables and values we want to intiialize on the new unit
		#this means we no longer have to keep grabbing the script and making a single change over and over, as it can be done all at once
		CreateTable ->initParams
		#getting where we fire from
		V3( -.5 <-launchAngle HALFPI + cos *, .45, -.5 <-launchAngle HALFPI + sin *) ->offset
		#@FireProjectile(<-offset)
		#burst timer
		Self GetUnitERNState if
			8.0 ->miniRechargeTime
			<-miniRechargeTime 4 * ->burstCounter
		else
			10.0 ->miniRechargeTime
			<-miniRechargeTime 2 * ->burstCounter
		endif
	endif

#creates projectils when firing
#takes in a V3 for offseting, so make sure there's a V3 on the stack
:FireProjectile
	GetObjPosition(Self "Rocket Turret" true) + ->firePos
	#it might be better to think of initParams as a dictionary, or at least in how it's used
	#each value has a key, in the form of a variable name. you can have copies of values but not keys(you'd overwrite the key+value when using a non-unique key)
	<-projSpeed Self GetUnitERNState if 2.0 mul endif ->initParams{"projSpeed"}
	<-launchAngle ->initParams{"launchAngle"}
	<-DAMAGE_MESH ->initParams{"DAMAGE_MESH"}
	<-DAMAGE_DIST ->initParams{"DAMAGE_DIST"}
	<-DAMAGE_DEPTH ->initParams{"DAMAGE_DEPTH"}
	<-target ->initParams{"TARGET"}
	1 ->initParams{"targeting"}

	CreateUnit(<-rocketShotGUID <-firePos <-initParams) ->shotUnit
	PlaySoundAtPosition("Sci Fi Explosion 12", 1, GetUnitPosition(self))
	
	#make it so it spawns facing the right way, instead of world forward
	<-shotUnit V3(1 <-launchAngle cos *, 0, 1 <-launchAngle sin *) SetUnitForward
	
	#Tag the damage map with the damage this shot will do. When the shot is destroyed, the damage will will
	#be automatically cleaned up (because we specified '<-shotUnit' as the unit to associate with the damage map call). -KC
	ApplyToDamageMap(<-shotUnit <-target.X <-target.Z <-DAMAGE_DIST <-DAMAGE_DEPTH 1000000 * false)
	
:Once
	Self 7 SetUnitPacketRequestRate

	#Gets called once and only once when unit is created -KC
	#as a note, it is also called on recompile
	RemoveUnitDamageMap(self)
	0 ->targeting
	-1 ->autoTargetX
	SetUnitDebugText(self "")
	-1 ->burstCounter
	#clear target
	V3(-1, -1, -1) ->target
		SetUnitSpecifiedTargetShowPath(self false)
	